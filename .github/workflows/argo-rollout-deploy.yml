name: Argo Rollout Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - test
        - prod
      image_tag:
        description: 'Image tag to deploy'
        required: true
        default: 'latest'
      strategy:
        description: 'Deployment strategy'
        required: true
        default: 'canary'
        type: choice
        options:
        - canary
        - blueGreen
      traffic_router:
        description: 'Traffic router'
        required: true
        default: 'istio'
        type: choice
        options:
        - istio
        - smi
        - nginx

env:
  AWS_REGION: ap-south-1
  IMAGE_REPO: docker.io/your-username/health-api

jobs:
  deploy:
    runs-on: ${{ github.event.inputs.environment == 'prod' && fromJSON(format('["self-hosted", "github-runner-{0}"]', 'higher')) || fromJSON(format('["self-hosted", "github-runner-{0}"]', 'lower')) }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up kubectl
      run: |
        echo "Setting up kubectl for ${{ github.event.inputs.environment }} environment"
        
        # Get kubeconfig from S3
        NETWORK_TIER="${{ github.event.inputs.environment == 'prod' && 'higher' || 'lower' }}"
        aws s3 cp s3://${{ secrets.TF_STATE_BUCKET }}/kubeconfig-${NETWORK_TIER}.yaml /tmp/kubeconfig
        
        # Set KUBECONFIG environment variable
        echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV

    - name: Install Argo Rollouts kubectl plugin
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x ./kubectl-argo-rollouts-linux-amd64
        sudo mv ./kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

    - name: Generate Rollout Manifest
      run: |
        # Set domain name based on environment
        if [ "${{ github.event.inputs.environment }}" == "dev" ]; then
          DOMAIN_NAME="dev.health-app.local"
        elif [ "${{ github.event.inputs.environment }}" == "test" ]; then
          DOMAIN_NAME="test.health-app.local"
        else
          DOMAIN_NAME="health-app.local"
        fi
        
        # Generate rollout manifest
        chmod +x scripts/generate-rollout.sh
        ./scripts/generate-rollout.sh \
          --namespace health-app-${{ github.event.inputs.environment }} \
          --image ${{ env.IMAGE_REPO }} \
          --tag ${{ github.event.inputs.image_tag }} \
          --strategy ${{ github.event.inputs.strategy }} \
          --router ${{ github.event.inputs.traffic_router }} \
          --domain $DOMAIN_NAME \
          --enable-istio true

    - name: Apply Rollout
      run: |
        kubectl apply -f k8s/generated/health-api-rollout-health-app-${{ github.event.inputs.environment }}.yaml
        
        # Wait for rollout to be healthy
        kubectl argo rollouts get rollout health-api -n health-app-${{ github.event.inputs.environment }} --watch
        
    - name: Verify Deployment
      run: |
        echo "Verifying deployment in namespace health-app-${{ github.event.inputs.environment }}"
        kubectl get rollout health-api -n health-app-${{ github.event.inputs.environment }} -o jsonpath='{.status.conditions[?(@.type=="Healthy")].status}'
        
        # Get services
        kubectl get svc -n health-app-${{ github.event.inputs.environment }}
        
        # If using Istio, get VirtualService
        if [ "${{ github.event.inputs.traffic_router }}" == "istio" ]; then
          kubectl get virtualservice -n health-app-${{ github.event.inputs.environment }}
        fi