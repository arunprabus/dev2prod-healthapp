name: Quick Kubeconfig Fix

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action'
        required: true
        type: choice
        options:
          - 'fix-secrets'
          - 'test-connection'

jobs:
  fix-kubeconfig:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Fix GitHub Secrets
        if: inputs.action == 'fix-secrets'
        run: |
          echo "🔧 Using existing kubeconfig file to fix GitHub secrets..."
          
          # Use the working kubeconfig file from the repo
          if [ -f "kubeconfig-lower.yaml" ]; then
            echo "✅ Found kubeconfig-lower.yaml"
            
            # Test the kubeconfig
            export KUBECONFIG=$PWD/kubeconfig-lower.yaml
            echo "🧪 Testing kubeconfig connection..."
            
            if timeout 30 kubectl cluster-info --request-timeout=10s; then
              echo "✅ Kubeconfig is working!"
              
              # Create base64 encoded version
              KUBECONFIG_B64=$(base64 -w 0 kubeconfig-lower.yaml)
              
              echo "🔐 Creating GitHub secrets..."
              
              # Get repository public key for encryption
              echo "🔑 Getting repository public key..."
              PUBLIC_KEY_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/secrets/public-key")
              
              PUBLIC_KEY=$(echo "$PUBLIC_KEY_RESPONSE" | jq -r '.key')
              KEY_ID=$(echo "$PUBLIC_KEY_RESPONSE" | jq -r '.key_id')
              
              if [ "$KEY_ID" = "null" ]; then
                echo "❌ Failed to get repository public key"
                exit 1
              fi
              
              echo "✅ Got public key (ID: $KEY_ID)"
              
              # Function to encrypt and create secret
              create_secret() {
                local secret_name=$1
                local secret_value=$2
                
                echo "🔐 Creating secret: $secret_name"
                
                # Encrypt using Python with PyNaCl
                ENCRYPTED=$(python3 -c "
              import base64
              import sys
              try:
                  import nacl.encoding, nacl.public
                  public_key = nacl.public.PublicKey(base64.b64decode('$PUBLIC_KEY'), nacl.encoding.RawEncoder())
                  sealed_box = nacl.public.SealedBox(public_key)
                  encrypted = sealed_box.encrypt(b'$secret_value')
                  print(base64.b64encode(encrypted).decode())
              except ImportError:
                  print('ERROR: PyNaCl not available')
                  sys.exit(1)
              ")
                
                if [ "$ENCRYPTED" = "ERROR: PyNaCl not available" ]; then
                  echo "⚠️ PyNaCl not available, installing..."
                  pip3 install PyNaCl
                  ENCRYPTED=$(python3 -c "
              import base64
              import nacl.encoding, nacl.public
              public_key = nacl.public.PublicKey(base64.b64decode('$PUBLIC_KEY'), nacl.encoding.RawEncoder())
              sealed_box = nacl.public.SealedBox(public_key)
              encrypted = sealed_box.encrypt(b'$secret_value')
              print(base64.b64encode(encrypted).decode())
              ")
                fi
                
                # Create secret via API
                RESPONSE=$(curl -s -X PUT \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/secrets/$secret_name" \
                  -d "{\"encrypted_value\":\"$ENCRYPTED\",\"key_id\":\"$KEY_ID\"}")
                
                if echo "$RESPONSE" | grep -q "error"; then
                  echo "❌ Failed to create $secret_name"
                  echo "$RESPONSE"
                else
                  echo "✅ Created $secret_name"
                fi
              }
              
              # Create the secrets
              create_secret "KUBECONFIG_DEV" "$KUBECONFIG_B64"
              create_secret "KUBECONFIG_TEST" "$KUBECONFIG_B64"
              
              echo "✅ GitHub secrets updated successfully!"
              echo ""
              echo "📋 Updated secrets:"
              echo "  - KUBECONFIG_DEV"
              echo "  - KUBECONFIG_TEST"
              
            else
              echo "⚠️ Connection test failed, but creating secrets anyway..."
              KUBECONFIG_B64=$(base64 -w 0 kubeconfig-lower.yaml)
              
              # Same encryption process for failed connection
              PUBLIC_KEY_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/secrets/public-key")
              PUBLIC_KEY=$(echo "$PUBLIC_KEY_RESPONSE" | jq -r '.key')
              KEY_ID=$(echo "$PUBLIC_KEY_RESPONSE" | jq -r '.key_id')
              
              create_secret() {
                local secret_name=$1
                local secret_value=$2
                pip3 install PyNaCl >/dev/null 2>&1
                ENCRYPTED=$(python3 -c "
              import base64
              import nacl.encoding, nacl.public
              public_key = nacl.public.PublicKey(base64.b64decode('$PUBLIC_KEY'), nacl.encoding.RawEncoder())
              sealed_box = nacl.public.SealedBox(public_key)
              encrypted = sealed_box.encrypt(b'$secret_value')
              print(base64.b64encode(encrypted).decode())
              ")
                curl -s -X PUT \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/secrets/$secret_name" \
                  -d "{\"encrypted_value\":\"$ENCRYPTED\",\"key_id\":\"$KEY_ID\"}" >/dev/null
              }
              
              create_secret "KUBECONFIG_DEV" "$KUBECONFIG_B64"
              create_secret "KUBECONFIG_TEST" "$KUBECONFIG_B64"
              echo "✅ Secrets created (connection may work from GitHub Actions)"
            fi
            
          else
            echo "❌ kubeconfig-lower.yaml not found in repository"
            echo "Available kubeconfig files:"
            ls -la kubeconfig*.yaml || echo "No kubeconfig files found"
          fi


      - name: Test Connection
        if: inputs.action == 'test-connection'
        run: |
          echo "🧪 Testing kubeconfig connection from secrets..."
          
          # Test KUBECONFIG_DEV
          echo "Testing KUBECONFIG_DEV..."
          echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > test-kubeconfig.yaml
          
          if [ -s test-kubeconfig.yaml ]; then
            export KUBECONFIG=$PWD/test-kubeconfig.yaml
            echo "📁 Kubeconfig content:"
            cat test-kubeconfig.yaml
            echo ""
            
            echo "🔗 Testing connection..."
            if timeout 30 kubectl cluster-info --request-timeout=10s; then
              echo "✅ KUBECONFIG_DEV is working!"
              kubectl get nodes
            else
              echo "❌ KUBECONFIG_DEV connection failed"
            fi
          else
            echo "❌ KUBECONFIG_DEV secret is empty or invalid"
          fi
          
          rm -f test-kubeconfig.yaml

      - name: Summary
        run: |
          echo "🎉 Kubeconfig fix completed!"
          echo ""
          echo "📋 Next steps:"
          echo "1. Test with: Actions → Kubeconfig Access → environment: dev → action: test-connection"
          echo "2. If working, you can now deploy applications"
          echo ""
          echo "💡 The kubeconfig points to: 43.205.211.129:6443"