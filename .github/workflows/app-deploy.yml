name: Application Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - 'dev'
          - 'test'
          - 'prod'
      app_image:
        description: 'Application image'
        required: false
        default: 'nginx:latest'
        type: string
      replicas:
        description: 'Number of replicas'
        required: false
        default: '2'
        type: string

jobs:
  deploy:
    runs-on: ${{ github.event.inputs.environment == 'prod' && fromJSON('["self-hosted", "github-runner-higher"]') || fromJSON('["self-hosted", "github-runner-lower"]') }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Setup Kubeconfig
        run: |
          case "${{ github.event.inputs.environment }}" in
            "dev")
              echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig.yaml
              ;;
            "test")
              echo "${{ secrets.KUBECONFIG_TEST }}" | base64 -d > kubeconfig.yaml
              ;;
            "prod")
              echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig.yaml
              ;;
          esac
          
          export KUBECONFIG=$PWD/kubeconfig.yaml
          echo "KUBECONFIG=$PWD/kubeconfig.yaml" >> $GITHUB_ENV

      - name: Test Connection
        run: |
          echo "ğŸ§ª Testing connection to ${{ github.event.inputs.environment }}..."
          if timeout 30 kubectl get nodes --request-timeout=20s; then
            echo "âœ… Connection successful!"
          else
            echo "âŒ Connection failed - cluster may not be ready"
            exit 1
          fi

      - name: Create Namespace
        run: |
          kubectl create namespace health-app-${{ github.event.inputs.environment }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Application
        run: |
          cat << EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: health-app
            namespace: health-app-${{ github.event.inputs.environment }}
          spec:
            replicas: ${{ github.event.inputs.replicas }}
            selector:
              matchLabels:
                app: health-app
            template:
              metadata:
                labels:
                  app: health-app
              spec:
                containers:
                - name: health-app
                  image: ${{ github.event.inputs.app_image }}
                  ports:
                  - containerPort: 80
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: health-app-service
            namespace: health-app-${{ github.event.inputs.environment }}
          spec:
            selector:
              app: health-app
            ports:
            - port: 80
              targetPort: 80
              nodePort: 30080
            type: NodePort
          EOF

      - name: Verify Deployment
        run: |
          echo "ğŸš€ Deployment Status:"
          kubectl get deployments -n health-app-${{ github.event.inputs.environment }}
          kubectl get pods -n health-app-${{ github.event.inputs.environment }}
          kubectl get services -n health-app-${{ github.event.inputs.environment }}
          
          echo ""
          echo "ğŸŒ Access URL:"
          K3S_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
          echo "http://${K3S_IP}:30080"