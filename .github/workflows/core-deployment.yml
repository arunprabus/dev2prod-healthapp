name: Core Deployment

on:
  repository_dispatch:
    types: [ app-deploy ]
  workflow_dispatch:
    inputs:
      app:
        description: 'Application'
        required: true
        default: 'health-api'
        type: string
      image:
        description: 'Container image'
        required: true
        default: 'arunprabusiva/health-api:latest'
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - test
          - prod
      runner_type:
        description: 'Runner Type'
        required: false
        default: 'github'
        type: choice
        options:
        - github
        - aws

env:
  AWS_REGION: ap-south-1

jobs:
  deploy:
    runs-on: ${{ github.event.inputs.runner_type == 'aws' && fromJSON(format('["self-hosted", "github-runner-{0}"]', 'monitoring')) || 'ubuntu-latest' }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        if: github.event.inputs.runner_type == 'github'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        if: github.event.inputs.runner_type == 'github'
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Setup kubeconfig
        run: |
          APP="${{ github.event.client_payload.app || github.event.inputs.app }}"
          IMAGE="${{ github.event.client_payload.image || github.event.inputs.image }}"
          ENV="${{ github.event.client_payload.environment || github.event.inputs.environment }}"
          
          echo "üöÄ Deploying $APP:$IMAGE to $ENV environment"
          echo "Runner: $(hostname)"
          
          # Setup kubeconfig based on environment
          if [ "$ENV" = "dev" ] || [ "$ENV" = "test" ]; then
            KUBECONFIG_SECRET="KUBECONFIG_$(echo $ENV | tr '[:lower:]' '[:upper:]')"
            NETWORK_TIER="lower"
          else
            KUBECONFIG_SECRET="KUBECONFIG_PROD"
            NETWORK_TIER="higher"
          fi
          
          echo "Using kubeconfig: $KUBECONFIG_SECRET for network: $NETWORK_TIER"
          
          # Set environment variables for next steps
          echo "APP_NAME=$APP" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE" >> $GITHUB_ENV
          echo "ENVIRONMENT=$ENV" >> $GITHUB_ENV
          echo "NAMESPACE=health-app-$ENV" >> $GITHUB_ENV
          echo "NETWORK_TIER=$NETWORK_TIER" >> $GITHUB_ENV

      - name: Download kubeconfig from S3
        run: |
          # Determine network tier based on environment
          if [ "$ENVIRONMENT" = "dev" ] || [ "$ENVIRONMENT" = "test" ]; then
            NETWORK_TIER="lower"
          else
            NETWORK_TIER="higher"
          fi
          
          echo "üíæ Downloading kubeconfig for $ENVIRONMENT environment (network: $NETWORK_TIER)"
          
          # Download kubeconfig from S3
          KUBECONFIG_KEY="kubeconfig/$NETWORK_TIER-kubeconfig.yaml"
          
          if aws s3 cp s3://${{ secrets.TF_STATE_BUCKET }}/$KUBECONFIG_KEY ~/.kube/config; then
            echo "‚úÖ Downloaded kubeconfig from S3: $KUBECONFIG_KEY"
            echo "üìÑ Kubeconfig contents:"
            cat ~/.kube/config
          else
            echo "‚ùå Failed to download kubeconfig from S3"
            echo "üí° Please run Core Infrastructure deployment first"
            exit 1
          fi
          
          # Check if cluster is reachable
          CLUSTER_IP=$(grep 'server:' ~/.kube/config | awk '{print $2}' | sed 's|https://||' | sed 's|:6443||')
          echo "üîç Testing connectivity to K3s cluster: $CLUSTER_IP:6443"
          
          if timeout 10 bash -c "</dev/tcp/$CLUSTER_IP/6443"; then
            echo "‚úÖ Port 6443 is reachable"
          else
            echo "‚ùå Cannot connect to $CLUSTER_IP:6443"
            echo "üí° Checking if K3s cluster is running..."
            
            # Check if instance is running
            INSTANCE_STATUS=$(aws ec2 describe-instances \
              --filters "Name=ip-address,Values=$CLUSTER_IP" \
              --query "Reservations[0].Instances[0].State.Name" \
              --output text 2>/dev/null || echo "None")
            
            if [ "$INSTANCE_STATUS" = "None" ]; then
              # Try with private IP filter
              INSTANCE_STATUS=$(aws ec2 describe-instances \
                --filters "Name=private-ip-address,Values=$CLUSTER_IP" \
                --query "Reservations[0].Instances[0].State.Name" \
                --output text 2>/dev/null || echo "None")
            fi
            
            echo "Instance status: $INSTANCE_STATUS"
            
            # Get instance details
            if [ "$INSTANCE_STATUS" != "None" ]; then
              INSTANCE_ID=$(aws ec2 describe-instances \
                --filters "Name=ip-address,Values=$CLUSTER_IP" \
                --query "Reservations[0].Instances[0].InstanceId" \
                --output text 2>/dev/null || echo "None")
              
              if [ "$INSTANCE_ID" != "None" ]; then
                echo "Instance ID: $INSTANCE_ID"
                echo "Instance details:"
                aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress]" --output table
              fi
            fi
            
            if [ "$INSTANCE_STATUS" != "running" ]; then
              echo "‚ùå K3s cluster instance is not running (Status: $INSTANCE_STATUS)"
              echo "üí° Please run Core Infrastructure deployment to start the cluster"
              
              # Try to start the instance if it's stopped
              if [ "$INSTANCE_STATUS" = "stopped" ] && [ "$INSTANCE_ID" != "None" ]; then
                echo "üîÑ Attempting to start the stopped instance..."
                aws ec2 start-instances --instance-ids $INSTANCE_ID
                echo "‚è≥ Waiting for instance to start..."
                aws ec2 wait instance-running --instance-ids $INSTANCE_ID
                echo "‚úÖ Instance started, waiting for K3s to be ready..."
                sleep 60  # Give K3s time to start
              else
                exit 1
              fi
            fi
          fi
          
          # Test connection
          kubectl get nodes --insecure-skip-tls-verify

      - name: Create namespace
        run: |
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Namespace $NAMESPACE ready"

      - name: Deploy application
        run: |
          echo "üöÄ Deploying $APP_NAME with image $IMAGE_NAME"
          
          # Check if deployment exists
          if kubectl get deployment $APP_NAME -n $NAMESPACE >/dev/null 2>&1; then
            echo "üìù Updating existing deployment"
            kubectl set image deployment/$APP_NAME $APP_NAME=$IMAGE_NAME -n $NAMESPACE
            kubectl annotate deployment/$APP_NAME deployment.kubernetes.io/revision- -n $NAMESPACE
          else
            echo "üÜï Creating new deployment"
            kubectl create deployment $APP_NAME --image=$IMAGE_NAME -n $NAMESPACE
            
            # Create service
            kubectl expose deployment $APP_NAME --port=80 --target-port=8080 -n $NAMESPACE --type=ClusterIP
            
            # Add labels
            kubectl label deployment $APP_NAME app=$APP_NAME version=latest -n $NAMESPACE
          fi
          
          # Wait for rollout
          echo "‚è≥ Waiting for deployment rollout..."
          kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment status"
          
          # Get deployment status
          kubectl get deployment $APP_NAME -n $NAMESPACE -o wide
          
          # Get pods
          echo "üìã Pod status:"
          kubectl get pods -l app=$APP_NAME -n $NAMESPACE -o wide
          
          # Get services
          echo "üåê Service status:"
          kubectl get services -l app=$APP_NAME -n $NAMESPACE
          
          # Check pod health
          READY_PODS=$(kubectl get pods -l app=$APP_NAME -n $NAMESPACE --no-headers | grep Running | wc -l)
          TOTAL_PODS=$(kubectl get pods -l app=$APP_NAME -n $NAMESPACE --no-headers | wc -l)
          
          echo "READY_PODS=$READY_PODS" >> $GITHUB_ENV
          echo "TOTAL_PODS=$TOTAL_PODS" >> $GITHUB_ENV
          
          if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$READY_PODS" -gt 0 ]; then
            echo "‚úÖ All pods are running successfully"
            echo "DEPLOYMENT_STATUS=success" >> $GITHUB_ENV
          else
            echo "‚ùå Some pods are not ready: $READY_PODS/$TOTAL_PODS"
            echo "DEPLOYMENT_STATUS=failed" >> $GITHUB_ENV
            kubectl describe pods -l app=$APP_NAME -n $NAMESPACE
            exit 1
          fi

      - name: Generate deployment summary
        if: always()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** $APP_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** $IMAGE_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** $NAMESPACE" >> $GITHUB_STEP_SUMMARY
          echo "**Network Tier:** $NETWORK_TIER" >> $GITHUB_STEP_SUMMARY
          echo "**Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üìä Deployment Status" >> $GITHUB_STEP_SUMMARY
          if [ "$DEPLOYMENT_STATUS" = "success" ]; then
            echo "**Status:** ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "**Pods Ready:** $READY_PODS/$TOTAL_PODS" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** ‚ùå Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "**Pods Ready:** ${READY_PODS:-0}/${TOTAL_PODS:-0}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üîç Resource Information" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get all -l app=$APP_NAME -n $NAMESPACE >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Resources not available" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.kube/config
          echo "üßπ Cleanup completed"