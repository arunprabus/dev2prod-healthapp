name: GitOps Deployment

on:
  repository_dispatch:
    types: [app-deploy]
  workflow_dispatch:
    inputs:
      app:
        description: 'Application name'
        required: true
        default: 'health-api'
        type: string
      image:
        description: 'Container image'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - test
        - prod

env:
  AWS_REGION: ap-south-1

jobs:
  gitops-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Use environment-specific kubeconfig
        ENV="${{ github.event.client_payload.environment || github.event.inputs.environment }}"
        if [[ -n "${{ secrets[format('KUBECONFIG_{0}', env.ENVIRONMENT)] }}" ]]; then
          echo "Using environment-specific kubeconfig for $ENV"
          echo "${{ secrets[format('KUBECONFIG_{0}', env.ENVIRONMENT)] }}" | base64 -d > ~/.kube/config
        else
          echo "Using default kubeconfig"
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
        fi

    - name: Extract deployment info
      id: deploy-info
      run: |
        # From repository_dispatch or manual input
        APP="${{ github.event.client_payload.app || github.event.inputs.app }}"
        IMAGE="${{ github.event.client_payload.image || github.event.inputs.image }}"
        ENV="${{ github.event.client_payload.environment || github.event.inputs.environment }}"
        
        echo "app=$APP" >> $GITHUB_OUTPUT
        echo "image=$IMAGE" >> $GITHUB_OUTPUT
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        
        echo "Deploying: $APP"
        echo "Image: $IMAGE"
        echo "Environment: $ENV"

    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Update deployment
      run: |
        APP="${{ steps.deploy-info.outputs.app }}"
        IMAGE="${{ steps.deploy-info.outputs.image }}"
        ENV="${{ steps.deploy-info.outputs.environment }}"
        
        DEPLOYMENT_NAME="${APP}-backend-${ENV}"
        NAMESPACE="health-app-${ENV}"
        
        # Check if deployment exists
        if kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE >/dev/null 2>&1; then
          echo "Updating existing deployment: $DEPLOYMENT_NAME"
          
          # Update image
          kubectl set image deployment/$DEPLOYMENT_NAME \
            $APP=$IMAGE -n $NAMESPACE
          
          # Wait for rollout
          kubectl rollout status deployment/$DEPLOYMENT_NAME \
            -n $NAMESPACE --timeout=300s
          
          echo "✅ Deployment updated successfully"
        else
          echo "❌ Deployment $DEPLOYMENT_NAME not found in namespace $NAMESPACE"
          echo "Available deployments:"
          kubectl get deployments -n $NAMESPACE || echo "Namespace may not exist"
          exit 1
        fi

    - name: Verify deployment
      run: |
        APP="${{ steps.deploy-info.outputs.app }}"
        ENV="${{ steps.deploy-info.outputs.environment }}"
        NAMESPACE="health-app-${ENV}"
        
        # Check pod status
        echo "Pod status:"
        kubectl get pods -l app=$APP -n $NAMESPACE
        
        # Check service status
        echo "Service status:"
        kubectl get services -l app=$APP -n $NAMESPACE
        
        # Check recent events
        echo "Recent events:"
        kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -10

    - name: Health check
      run: |
        APP="${{ steps.deploy-info.outputs.app }}"
        ENV="${{ steps.deploy-info.outputs.environment }}"
        NAMESPACE="health-app-${ENV}"
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pods -l app=$APP -n $NAMESPACE --timeout=120s || true
        
        # Check if health endpoint is available (optional)
        SERVICE_NAME="${APP}-service"
        if kubectl get service $SERVICE_NAME -n $NAMESPACE >/dev/null 2>&1; then
          echo "Service $SERVICE_NAME found"
          
          # Port forward and test (optional)
          # kubectl port-forward svc/$SERVICE_NAME 8080:80 -n $NAMESPACE &
          # sleep 5
          # curl -f http://localhost:8080/health || echo "Health check failed"
        fi

    - name: Generate summary
      if: always()
      run: |
        APP="${{ steps.deploy-info.outputs.app }}"
        IMAGE="${{ steps.deploy-info.outputs.image }}"
        ENV="${{ steps.deploy-info.outputs.environment }}"
        
        echo "## 🚀 GitOps Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "* Application: $APP" >> $GITHUB_STEP_SUMMARY
        echo "* Image: $IMAGE" >> $GITHUB_STEP_SUMMARY
        echo "* Environment: $ENV" >> $GITHUB_STEP_SUMMARY
        echo "* Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "* Triggered by: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "* Date: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "### ✅ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "Application $APP has been successfully deployed to $ENV environment" >> $GITHUB_STEP_SUMMARY
        else
          echo "### ❌ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for details" >> $GITHUB_STEP_SUMMARY
        fi